import SVGLoader from './lib/SVGLoader';
import DraggableZ from './lib/DraggableZ';
import widgets from './widgets';

// chart.js defaults
if(Chart) {
  Chart.defaults.global.defaultFontFamily   = "'Roboto','Helvetica Neue','Arial', sans-serif";
  Chart.defaults.global.responsive = true;
  Chart.defaults.global.maintainAspectRatio = false;
}

$(function() {

  SVGLoader.loadPlaceholders($('*[data-svg-src]'));

  // global callbacks
  widgets.forEach(widget => {

    widget.on('render', () => {
      SVGLoader.loadPlaceholders($(widget.template).find('[data-svg-src]'));
    });

    widget.on('changed', params => {
      if(widget._synced) {
        console.log('will sync up');
      } else {
        console.log('will not sync up');
      }
    });

    widget.on('synced', is => {
      $(widget.template).find('.widget-toolbar input').prop('disabled', is);
    });

  });

  // grid
  const UI = new DraggableZ($("#grid"), widgets);

  // handles a sync toggle
  function handleSyncToggle(e) {
    let toggle = $(this);
    if(toggle.is(':checked')) {
      UI.dispatchEvent('sync.on');
    } else {
      UI.dispatchEvent('sync.off');
    }
  }

  // scoped function for initializing the header behavior
  function initializeHeaderToolbar() {

    let toolbar = $("#app-header .widget-toolbar");
    let date = toolbar.find('input#toolbar-date');
    let period = toolbar.find('input[name="toolbar-period"]');
    let toggle = $('#app-header input#sync-widgets');


    // binds the sync toggle handle to the toggle, and to the handler
    // once for initialization
    toggle.on('change', handleSyncToggle);
    handleSyncToggle();

    // initialize the date picker
    date.datepicker({
      dateFormat: 'yy-mm-dd',
      maxDate: new Date()
    }).datepicker('setDate', new Date());

    // bind the listeners
    date.on('change', e => {
      widgets.forEach(widget => {
        if(!widget._synced) return;
        widget.api.date($(e.currentTarget).val()).fetch();
      });
    });

    period.on('change', e => {
      widgets.forEach(widget => {
        if(!widget._synced) return;
        widget.api.period($(e.currentTarget).val()).fetch();
      });
    });

  }

  UI.on('sync.on', () => {
    $('body').addClass('mode-sync');
    $("#app-header .widget-toolbar input").prop('disabled', false);
    widgets.forEach(widget => widget.synced(true));
  });

  UI.on('sync.off', () => {
    $('body').removeClass('mode-sync');
    widgets.forEach(widget => widget.synced(false));
    $("#app-header .widget-toolbar input").prop('disabled', true);
  });

  initializeHeaderToolbar();

});
