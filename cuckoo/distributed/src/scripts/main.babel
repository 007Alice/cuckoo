import DraggableUI          from './lib/DraggableUI';
import { StatsApi, apilog } from './lib/StatsApi';
import SVGLoader            from './lib/SVGLoader';

const widgets = {};

$(function() {

  // create UI instance
  const UI = new DraggableUI(document.getElementById('grid'));

  // callback function for the widgets to perform some after-init stuff, graphs will
  // be initialized here as well.
  function onWidgetRender() {
    SVGLoader.loadPlaceholders($(this.template.find('[data-svg-src]')));
  }

  // widget-specific API middleware. it consumes a bare response
  // and returns it altered to the flavor of the output (in this case chartjs.)
  // it will make use of the api-specific params set for breaking down the content
  // to 'just' what chartjs needs.
  function responseBreakdownTasks(res, params, silent) {

    let log = apilog(silent);

    let result = {
      labels: [],
      datasets: []
    }

    let addDataset = (set) => {

      let selected = res[set];

      if(params.period) {
        selected = selected[params.period];
      } else {
        selected = selected['hour'];
      }

      result.labels = selected.points.map(point => point.datetime);
      result.datasets.push({
        label: set,
        data: selected.points.map(point => point.value)
      });

    }

    if(params.include.indexOf(',') > -1) {
      params.include.split(',').forEach(inc => addDataset(inc));
    } else {
      addDataset(params.include)
    }

    return result;

  }

  /*
    WIDGET: TASK_COMPLETED
   */
  widgets['task_completed'] = UI.widget('tasks_completed', {
    template: $("#widget--tasks-complete"),
    elementId: $("#widget--tasks-complete").attr('id'),
    widgetLayout: {
      width: 6,
      height: 7,
      x: 0,
      y: 0
    },
    loaderText: 'Loading completed tasks',

    // api configuration
    api: {
      params: {
        include: 'task_completed,task_uncompleted'
      },
      transform: responseBreakdownTasks
    }

  }).on('render', [onWidgetRender]);

  /*
    WIDGET: TASK_UNCOMPLETED
   */
  widgets['task_uncompleted'] = UI.widget('tasks_uncompleted', {
    template: $("#widget--tasks-incomplete"),
    elementId: $("#widget--tasks-incomplete").attr('id'),
    widgetLayout: {
      width: 6,
      height: 5,
      x: 6,
      y: 0
    },
    loaderText: 'Loading uncompleted tasks',

    // api configuration
    api: {
      params: {
        include: 'task_uncompleted'
      },
      transform: responseBreakdownTasks
    }

  }).on('render', [onWidgetRender]);

  UI.draw();

});

// underneath code is going to be a single instance per widget to allow for asynchronous
// requests. That means that the UI won't break entirely if some request is failing, the others
// keep on working. This implementation is because some calls would take longer than the other,
// making it a hell to load this page properly without lacking a lot of UX (waiting on the other
// elements etc.) stay tuned.

// // create API wrapper instance
// const API = new StatsApi();
//
// // api event: request sent
// API.on('request', data => {
//   // console.log('API started a request.');
// });
//
// // api event: request received
// API.on('receive', data => {
//   // console.log('API resolved a request successfull.');
// });
//
// // api event: errored somewhere
// API.on('error', err => {
//   // console.log('API gave an error.');
// });

// 1: fetching data with the api
// API.fetch('task_completed').then(data => {
//   console.log(data);
// }).catch(err => {
//   console.log(err);
// });
