import SVGLoader             from '../lib/SVGLoader';
import { fabricate, colors } from '../lib/DraggableZ';

// widget-specific API middleware. it consumes a bare response
// and returns it altered to the flavor of the output (in this case chartjs.)
// it will make use of the api-specific params set for breaking down the content
// to 'just' what chartjs needs.
function responseBreakdown(res, params, silent) {

  let result = {
    labels: [],
    datasets: []
  }

  let addDataset = (set) => {

    let selected = res[set];

    if(params.period) {
      selected = selected[params.period];
    } else {
      selected = selected['hour'];
    }

    result.labels = selected.points.map(point => moment(point.datetime).format('m'));

    result.datasets.push({
      label: set,
      data: selected.points.map(point => point.value)
    });

  }

  if(params.include.indexOf(',') > -1) {
    params.include.split(',').forEach(inc => addDataset(inc));
  } else {
    addDataset(params.include)
  }

  return result;

}

/*
  Widget properties
 */
const widget = fabricate('tasks', {

  template: $("#widget--tasks"),
  elementId: $("#widget--tasks").attr('id'),
  widgetLayout: {
    width: 6,
    height: 6,
    x: 0,
    y: 3
  },
  loaderText: 'Loading',

  chartHeight: 120,

  // chart configuration
  chart: {
    type: 'line',
    options: {
      responsive: true,
      color: colors,
      legend: {
        position: 'bottom',
        strokeStyle: false,
        labels: {
          usePointStyle: true
        }
      },
      scales: {
        yAxes: [{
          ticks: {
            beginAtZero: true
          }
        }],
        xAxes: [{
          stepSize: 100
        }]
      }
    },

    // layout per data entry, in order.
    dataLayout: [

      // task_completed
      {
        label: "Completed",
        fill: false,
        backgroundColor: colors.darkPurple,
        borderColor: colors.darkPurple,
        borderWidth: 1,
        pointRadius: 2
      },

      // task_uncompleted
      {
        label: "Uncompleted",
        fill: false,
        backgroundColor: colors.queenBlue,
        borderColor: colors.queenBlue,
        borderWidth: 1,
        pointRadius: 2
      }

    ]

  },

  // api configuration
  api: {
    params: {
      include: 'task_completed,task_uncompleted'
    },
    transform: responseBreakdown
  }

});

/*
  Widget event handling
 */
widget.on('render', function() {

  let chart = $(this.template).find('.widget-chart');

  let rerender = () => {
    this.chart.destroy();
    this.pull();
  }

  // load svg icons
  SVGLoader.loadPlaceholders($(this.template).find('[data-svg-src]'));

  // initialize datepicker
  $(this.template).find('[data-datepicker]').datepicker({
    dateFormat: 'yy-mm-dd'
  }).datepicker('setDate', new Date());

  // start listening to toolbar changes (PROOF OF CONCEPT, THIS IS GOING TO BE ABSTRACTIFIED)
  let toolbar = $(this.template).find('.widget-toolbar');
  let toolbarDate = toolbar.find('input[name="tasks-date"]');
  let toolbarPeriod = toolbar.find('input[name="tasks-period"]');

  toolbarDate.on('change', e => {
    let t = $(e.currentTarget);
    let val = t.val()
    this.api.date(t.val());
    rerender();
  });

  toolbarPeriod.on('change', e => {
    this.api.period($(e.currentTarget).val());
    rerender();
  });

  // bind the nodes and display any node related controls
  this.api.on('receive', data => {

    if(data.original.nodes && !widget.hasNodes) {

      let select = $(widget.template).find('.widget-toolbar select#tasks-filter-nodes');

      // sort on order and append to select
      data.original.nodes.sort((a, b) => {
        if(a < b) return -1;
        if(a > b) return 1;
        return 0;
      }).forEach(node => {
        select.append(`<option value="${node}">${node}</option>`);
      });

      // display the node controls
      $(widget.template).find('.control-nodes').addClass('has-nodes');

      // bind a change event to that same select to respond to it.
      select.bind('change', e => {
        widget.api.node(select.val());
        rerender();
      });

      widget.hasNodes = true;

    }

  });

});

// exports the UI widget configuration
export default widget;
