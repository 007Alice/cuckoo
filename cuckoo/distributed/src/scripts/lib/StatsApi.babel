import { config } from '../config';

// global configuration aliases
const API_BASE  = config.API_BASE;
const API_HOST  = config.API_HOST;

// cross-pointers to the python implementation, these parameters
// mirror the API implementations. When new options are added to the
// API backend, they should be persisted in these variables.
const SUPPORTED_INCLUDES = [
  'task_completed',
  'task_uncompleted',
  'vm_running',
  'disk_usage',
  'cpu_usage',
  'memory_usage',
  'amount_prio_queued'
]

/*
  This is a utility wrapper around the stats api. It translates
  the REST service to an easy-to-use javascript class.
 */
export default class StatsAPI {

  constructor(options = {}) {

    let config = this.config = $.extend({
      params: {},
      transform: []
    }, options);

    // stores callbacks to their eventtypes, these are dispatched
    // with the _dispatchEvent() method
    this.events = {
      request: [],
      receive: [],
      error: []
    }

    // optional parameters
    this.params = {
      include: config.params.include || null,
      period: config.params.period || 'hour',
      date: config.params.date || null
    }

    // stores an array of middleware-like functions that will do something
    // after the response data has been received. Think in object formatting
    // or mapping for use out of the API context (Chart.js expects data in a
    // particular serialization and configurations. Allthough the API returns the
    // data differently, hence it needs some mapping.)
    this.transformators = [];

    // initialize transformations from config
    if(config.transform) {
      if(config.transform instanceof Array) {
        config.transform.forEach(tr => this.transform(tr));
      } else {
        this.transform(config.transform);
      }
    }

  }

  // buildURL utility that wraps all params into a single url format to request
  // to the api
  buildURL() {

    let url = `${API_HOST}/${API_BASE}`;

    let _before = (str) => {
      if(str.indexOf('?') < 1) {
        str += '?';
      } else {
        str += '&';
      }
      return str;
    }

    if(this.params.date) {
      url += `/${this.params.date}`;
    }

    if(this.params.period) {
      url = _before(url);
      url += `period=${this.params.period}`;
    }

    if(this.params.include) {
      url = _before(url);
      url += `include=${this.params.include}`;
    }

    return url;

  }

  // fetch - calls to the database, resolves like a promise the es6 way!
  fetch() {

    let url,
        self = this;

    return new Promise((resolve, reject) => {

        url = this.buildURL();

        // dispatch the 'request' event
        self._dispatchEvent('request', { url: url });

        $.ajax({
          url: url,
          method: 'GET',
          dataType: 'json',
          contentType: 'application/json'
        }).done((response, status) => {

          let transformed = {};

          if(self.transformators.length) {
            self.transformators.forEach(transformation => transformed = transformation(response, self.params));
            transformed._wasTransformed = true;
          }

          // dispatch the 'receive' event
          self._dispatchEvent('receive', {
            url: url,
            original: response,
            data: transformed._wasTransformed ? transformed : response,
            params: self.params
          });

          // resolve the promise when the ajax call returned OK from the server
          // with the response data and other stuff for front-end handling.
          return resolve({
            status: (status === "success") ? 200 : status,
            url: url,
            data: response
          });

        }).fail((xhr, err) => {

          // dispatch the 'error' event
          self._dispatchEvent('error', {
            url: url
          });

          // reject on a failing xhr call, with as lots of reference stuff
          // as possible for catching up in the frontend on this error.
          return reject({
            url: url,
            status: err.status,
            message: `The request failed.`,
            error: err,
            xhr: xhr
          });

        });

    });

  }

  transform(tr) {
    this.transformators.push(tr);
    return this;
  }

  // general event listener utility
  on(eventName = null, cb = function(){}) {
    // opt out if the event is invalid
    if(!this.events[eventName]) return false;
    this.events[eventName].push(cb);
    return this;
  }

  // dispatches events
  _dispatchEvent(eventName, data = {}) {
    if(!this.events[eventName]) return false;
    this.events[eventName].forEach(fn => {
      if(typeof fn === 'function') fn.apply(this, [data]);
    });
    return this;
  }

  // easy-param swapping to 'scroll' through the api easily, a bit like:
  // StatsApi.include('task_completed').period().fetch().then(...)
  // - these methods alter the this.params{} object

  // sets the data inclusion parameters
  include(includeParams) {
    this.params.includes = includeParams;
    return this;
  }

  // sets the periods (day,week,month)
  period(periods) {
    this.params.period = periods;
    return this;
  }

  // sets the date of the dataset
  date(date) {
    this.params.date = date;
    return this;
  }

}

// nooping for silent mode
export function apilog(silent) {
  if(silent) {
    return () => true;
  } else {
    return console.log;
  }
}
