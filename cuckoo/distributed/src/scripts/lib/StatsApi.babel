import { config } from '../config';

// global configuration aliases
const API_BASE  = config.API_BASE;
const API_HOST  = config.API_HOST;

// cross-pointers to the python implementation, these parameters
// mirror the API implementations. When new options are added to the
// API backend, they should be persisted in these variables.
const SUPPORTED_INCLUDES = [
  'task_completed',
  'task_uncompleted',
  'vm_running',
  'disk_usage',
  'cpu_usage',
  'memory_usage',
  'amount_prio_queued'
]

/*
  This is a utility wrapper around the stats api. It translates
  the REST service to an easy-to-use javascript class.
 */
export default class StatsAPI {

  constructor(defaultEndpoint) {

    // stores a cached response from the api
    this.store = {};

    // stores callbacks to their eventtypes, these are dispatched
    // with the _dispatchEvent() method
    this.events = {
      request: [],
      receive: [],
      error: []
    }

    // stores an array of middleware-like functions that will do something
    // after the response data has been received. Think in object formatting
    // or mapping for use out of the API context (Chart.js expects data in a
    // particular serialization and configurations. Allthough the API returns the
    // data differently, hence it needs some mapping.)
    this.transforms = [];
    this.defaultInclude = false;

  }

  // fetch - calls to the database, resolves like a promise the es6 way!
  fetch(include = '') {

    let url,
        self = this;

    return new Promise((resolve, reject) => {

        url = `${API_HOST}/${API_BASE}`;

        if(self.defaultInclude) {
          include = self.defaultInclude;
        }

        if(include !== '') {
          if(SUPPORTED_INCLUDES.indexOf(include) > -1) {
            url += `?include=${include}`;
          } else {
            return reject({
              status: 0,
              message: `'${include}' is either not supported or mapped.`,
              error: {}
            });
          }
        }

        // dispatch the 'request' event
        self._dispatchEvent('request', { url: url });

        $.ajax({
          url: url,
          method: 'GET',
          dataType: 'json',
          contentType: 'application/json'
        }).done((response, status) => {

          if(self.transforms.length) {
            self.transforms.forEach(transformation => transformation(response));
          }

          // dispatch the 'receive' event
          self._dispatchEvent('receive', {
            url: url,
            original: response,
            data: response
          });

          // resolve the promise when the ajax call returned OK from the server
          // with the response data and other stuff for front-end handling.
          return resolve({
            status: (status === "success") ? 200 : status,
            url: url,
            data: response
          });

        }).fail((xhr, err) => {

          // dispatch the 'error' event
          self._dispatchEvent('error', {
            url: url
          });

          // reject on a failing xhr call, with as lots of reference stuff
          // as possible for catching up in the frontend on this error.
          return reject({
            url: url,
            status: err.status,
            message: `The request failed.`,
            error: err,
            xhr: xhr
          });

        });

    });

  }

  transform(tr) {

    // test if the transform really is doing a transform
    let testJSON = {'foo': 'bar','baz': ['foo','bar','baz']};
    let _testTransform = tr(testJSON);
    if(typeof _testTransform !== 'object') {
      console.error('Transform function should return an object');
    } else {
      this.transforms.push(tr);
    }

  }

  // general event listener utility
  on(eventName = null, cb = function(){}) {
    // opt out if the event is invalid
    if(!this.events[eventName]) return false;
    this.events[eventName].push(cb);
  }

  // dispatches events
  _dispatchEvent(eventName, data = {}) {
    if(!this.events[eventName]) return false;
    this.events[eventName].forEach(fn => {
      if(typeof fn === 'function') fn.apply(this, data);
    });
  }

}
