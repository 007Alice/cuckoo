import StatsAPI from './StatsAPI';

// placeholder empty function => true
let noop = () => true;

function parseFragment(fragment) {
  let result = $.parseHTML(fragment.html());
  $(result).attr('id', $(fragment).attr('id'));
  fragment.remove();
  return $(result);
}

/*
  Defines a simple widget - tries to correspond to the Gridstack API
  - every widget has an API instance to control itself from within. That means
    that if 1 call is busy being executed, it will not stop the other charts from
    rendering their own data.
 */
class DraggableUIWidget {

  constructor(name, config) {

    this.name = name || 'widget';
    this.template = config.template || '';

    this.widgetLayout = $.extend({
      el: null,
      x: 0,
      y: 0,
      width: 1,
      height: 1,
      minWidth: 1,
      maxWidth: 1,
      minHeight: 1,
      maxHeight: 1,
      id: null
    }, config.widgetLayout);

    this.events = {
      render: []
    };

    // api-specific
    this.api_endpoint = config.api_endpoint;
    this.api = new StatsAPI();

    // chartjs-specific
    this.chart = null;
    this.chartOptions = $.extend({
      type: 'line',
      data: {
        labels: [0, 20, 30, 40, 50, 60, 70, 80, 90, 100],
        datasets: [{
          label: "My first dataset",
          data: [14, 2, 22, 47, 59, 32, 78, 92, 62, 73]
        }]
      },
      options: {}
    }, config.chart);

  }

  // injects a grid widget to the frontend
  inject(grid) {

    let template = $(this.template);
    let id       = template.attr('id');

    // set html in grid
    grid.container.append(template);

    template.wrap(`
      <div
        class='grid-stack-item'
        data-gs-width='${this.widgetLayout.width}'
        data-gs-height='${this.widgetLayout.height}'
        data-gs-x='${this.widgetLayout.x}'
        data-gs-y='${this.widgetLayout.y}'
        data-gs-id='${this.name}'
        data-gs-no-resize='true'
        data-gs-id='${id}'
        id='${id}'
      ></div>
    `);

    // template.id = template.childNode;
    grid.makeWidget($(`#${id}`));
    this.dispatchEvent('render', {}, () => {
      this.createChart();
    });

  }

  // event trigger
  on(evt, cb = noop) {

    let add = (evt,cb) => this.events[evt].push(cb);

    if(cb instanceof Array) {
      cb.forEach(cba => add(evt, cba));
    } else {
      if(this.events[evt]) {
        add(evt, cb)
      }
    }

    return this;
  }

  dispatchEvent(evt, data = {}, cb = noop) {
    if(this.events[evt]) {
      this.events[evt].forEach(callback => {
        if(callback instanceof Function) {
          callback.apply(this);
          cb();
        }
      });
    }

    return this;
  }

  // starts drawing the chart into widget-chart
  createChart() {
    let ctx = this.template.find('.widget-chart canvas');
    if(!this.chart && ctx.length) {
      let c = new Chart(ctx[0], this.chartOptions);
    }
  }

}

/*
  class DraggableUI
    - controls draggable grids
 */
class DraggableUI {

  constructor(context) {
    this.ctx = $(context);
    this.grid = null;
    this.widgets = {};
    return this.initialise();
  }

  initialise() {

    this.ctx.gridstack({
      animate: true,
      disableResize: true,
      draggable: {
        handle: '.widget-handle'
      }
    });

    // apply initialized grid api to the controller
    // class.
    this.grid = this.ctx.data('gridstack');

    return this;

  }

  widget(name, options) {

    let widget;

    if(options.template.length && options.template) {
      options.template = parseFragment(options.template);
    }

    // let widget;
    if(name) {
      this.widgets[name] = widget = new DraggableUIWidget(name, options);
    } else {
      console.log('A name has to be given.');
    }

    return widget;
  }

  draw() {

    // renders all the defined widgets to the grid
    for(let w in this.widgets) {
      let widget = this.widgets[w];
      widget.inject(this.grid);
    }

    this.grid.commit();

    return this;
  }

}

export default DraggableUI;
