import StatsAPI from './StatsAPI';
import WidgetLoader from './WidgetLoader';

// placeholder empty function => true
let noop = () => true;

function parseFragment(fragment) {
  let result = $.parseHTML(fragment.html());
  $(result).attr('id', $(fragment).attr('id'));
  fragment.remove();
  return $(result).eq(result.length-1);
}

/*
  Defines a simple widget - tries to correspond to the Gridstack API
  - every widget has an API instance to control itself from within. That means
    that if 1 call is busy being executed, it will not stop the other charts from
    rendering their own data.
 */
class DraggableUIWidget {

  constructor(name, config) {

    this.name = name || 'widget';
    this.template = config.template || '';
    this.elementId = config.elementId || undefined;

    this.widgetLayout = $.extend({
      el: null,
      x: 0,
      y: 0,
      width: 1,
      height: 1,
      id: null
    }, config.widgetLayout);

    this.events = {
      render: [],
      received: [],
      loading: [],
      loaded: []
    };

    // api-specific
    this.api                = new StatsAPI(config.api || {});
    this.api.defaultInclude = config.request || false;

    // chartjs-specific
    this.chart = null;
    this.chartOptions = $.extend({
      type: 'line',
      data: {},
      options: {}
    }, config.chart);

    // configure the widget loader
    this.loader = new WidgetLoader($(this.template).find('.widget-loader'), this, config.loaderText || null);

    // wire all the implemented services
    this._start();

  }

  // injects a grid widget to the frontend
  inject(grid) {

    let widget;
    let template = $(this.template);

    // set html in grid
    grid.container.append(template);

    // append the attributes
    template.attr('data-gs-width', this.widgetLayout.width);
    template.attr('data-gs-height', this.widgetLayout.height);
    template.attr('data-gs-x', this.widgetLayout.x);
    template.attr('data-gs-y', this.widgetLayout.y);
    template.attr('data-gs-no-resize', true);
    template.attr('id', this.elementId);

    widget = grid.makeWidget(`#${this.elementId}`);

    this.dispatchEvent('render');

  }

  // event trigger
  on(evt, cb = noop) {

    let add = (evt,cb) => this.events[evt].push(cb);

    if(cb instanceof Array) {
      cb.forEach(cba => add(evt, cba));
    } else {
      if(this.events[evt]) {
        add(evt, cb)
      }
    }

    return this;
  }

  dispatchEvent(evt, data = {}, cb = noop) {
    if(this.events[evt]) {
      this.events[evt].forEach(callback => {
        if(callback instanceof Function) {
          callback.apply(this);
          cb();
        }
      });
    }

    return this;
  }

  pull() {
    return this.api.fetch();
  }

  // starts drawing the chart into widget-chart
  createChart() {

    let c,
        ctx = this.template.find('.widget-chart canvas');

    if(!this.chart && ctx.length) {
      c = new Chart(ctx[0], this.chartOptions);
      $(this.template).data('chart', c);
    }

  }

  // internal working-togethers
  _start() {

    // after we pulled, start drawing the canvas
    this.api.on('receive', res => {
      if(res.data) {
        this.chartOptions.data = res.data;
        this.createChart();
      }
    });

    this.pull();

  }

}

/*
  class DraggableUI
    - controls draggable grids
 */
class DraggableUI {

  constructor(context) {
    this.ctx = $(context);
    this.grid = null;
    this.widgets = {};
    return this.initialise();
  }

  initialise() {

    this.ctx.gridstack({
      animate: true,
      disableResize: true,
      draggable: {
        handle: '.widget-handle',
        appendTo: 'body',
        scroll: false
      }
    });

    // apply initialized grid api to the controller
    // class.
    this.grid = this.ctx.data('gridstack');

    return this;

  }

  widget(name, options) {

    let widget;

    if(options.template.length && options.template) {
      options.template = parseFragment(options.template);
    }

    // let widget;
    if(name) {
      this.widgets[name] = widget = new DraggableUIWidget(name, options);
    } else {
      console.log('A name has to be given.');
    }

    return widget;
  }

  draw() {

    let gs = this.grid;

    // renders all the defined widgets to the grid
    for(let w in this.widgets) {
      gs.batchUpdate();
      let widget = this.widgets[w];
      widget.inject(gs);
      gs.commit();
    }

    return this;
  }

}

export default DraggableUI;
